---
title: 'OS-Level Control'
description: 'Direct operating system control for precise browser automation and AI agent interactions'
---

# OS-Level Control

OS-level control provides direct access to operating system primitives like mouse movements, keyboard input, and screen interactions within your browser sessions. This approach offers more precise control than traditional web automation methods and is particularly powerful when combined with AI agents and vision-based models.

## Why OS-Level Control?

### Superior AI Agent Performance

**Vision-based AI models perform significantly better** when they can interact with the browser using the same primitives humans use:

- **Visual Understanding**: AI agents that process screenshots can directly translate visual elements to precise coordinates
- **Natural Interaction Patterns**: Mouse movements and keyboard input mirror human behavior more closely than DOM manipulation
- **Complex UI Handling**: Works with dynamic content, canvas elements, and third-party widgets that are difficult to target with traditional selectors
- **Cross-Platform Consistency**: OS-level operations work identically across different websites and applications

### Beyond Traditional Web Automation

While CDP (Chrome DevTools Protocol) is excellent for many tasks, OS-level control excels when you need:

- **Pixel-perfect positioning** for complex interfaces
- **Interaction with non-standard elements** (Flash, WebGL, embedded applications)
- **Simulation of human-like behavior** with realistic timing and movement patterns
- **Screenshot-driven workflows** where AI agents analyze visual content

## Core Capabilities

### Mouse Operations

Control mouse interactions with pixel-level precision:

<CodeGroup>
```javascript Basic Click
// Single click at coordinates
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/mouse/click`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    x: 400,
    y: 300,
    button: 'left' // 'left', 'middle', 'right'
  })
});
```

```javascript Advanced Mouse Control
// Double-click for text selection
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/mouse/doubleClick`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ x: 500, y: 200 })
});

// Mouse down and up for custom gestures
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/mouse/down`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ x: 100, y: 100, button: 'left' })
});

// Move while holding down (drag)
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/mouse/move`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ x: 300, y: 300 })
});

// Release
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/mouse/up`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ x: 300, y: 300 })
});
```
</CodeGroup>

### Drag and Drop

Perform complex drag and drop operations in a single command:

```javascript
// Drag file from desktop to upload area
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/drag-and-drop`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    startX: 200,
    startY: 150,
    endX: 600,
    endY: 400,
    button: 'left'
  })
});
```

### Keyboard Input

Send text and keyboard shortcuts with human-like timing:

<CodeGroup>
```javascript Text Input
// Type text with optional delay between keystrokes
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/keyboard/type`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    text: "Hello, world!",
    delay: 50 // milliseconds between keystrokes
  })
});
```

```javascript Keyboard Shortcuts
// Execute keyboard shortcuts
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/keyboard/shortcut`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    keys: ['Ctrl', 'a'], // Select all
    holdTime: 100 // Hold keys for 100ms
  })
});

// Common shortcuts
const shortcuts = {
  selectAll: ['Ctrl', 'a'],
  copy: ['Ctrl', 'c'],
  paste: ['Ctrl', 'v'],
  undo: ['Ctrl', 'z'],
  save: ['Ctrl', 's'],
  refresh: ['F5']
};
```
</CodeGroup>

### Scrolling

Control page scrolling with precision:

```javascript
// Scroll at specific coordinates
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/scroll`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    x: 400,           // Scroll position
    y: 300,
    deltaX: 0,        // Horizontal scroll amount
    deltaY: 200,      // Vertical scroll amount (positive = down)
    steps: 5          // Number of steps for smooth scrolling
  })
});
```

### Screenshots

Capture visual state for AI analysis:

```javascript
// Take screenshot of current browser state
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/screenshot`, {
  method: 'GET',
  headers: {
    'anchor-api-key': 'your-api-key'
  }
});

const imageBuffer = await response.arrayBuffer();
// Process screenshot with vision AI model
```

### Clipboard Operations

Manage clipboard content programmatically:

<CodeGroup>
```javascript Reading Clipboard
// Get current clipboard content
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/clipboard`, {
  method: 'GET',
  headers: {
    'anchor-api-key': 'your-api-key'
  }
});

const { data } = await response.json();
console.log('Clipboard content:', data.text);
```

```javascript Setting Clipboard
// Set clipboard content
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/clipboard`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    text: "Content to copy"
  })
});

// Trigger copy operation (copies selected text)
const copyResponse = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/copy`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key'
  }
});

// Trigger paste operation
await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/paste`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    text: "Text to paste"
  })
});
```
</CodeGroup>

### Navigation

Direct URL navigation:

```javascript
// Navigate to a specific URL
const response = await fetch(`https://api.anchorbrowser.io/v1/sessions/${sessionId}/goto`, {
  method: 'POST',
  headers: {
    'anchor-api-key': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    url: "https://example.com"
  })
});
```

## AI Agent Integration Patterns

### Vision-Based Workflow

Here's how AI agents typically use OS-level control with vision models:

```javascript
async function aiDrivenInteraction(sessionId, task) {
  // 1. Take screenshot to analyze current state
  const screenshot = await takeScreenshot(sessionId);
  
  // 2. Send to vision AI model
  const analysis = await visionModel.analyze(screenshot, task);
  
  // 3. Execute recommended actions
  for (const action of analysis.actions) {
    switch(action.type) {
      case 'click':
        await click(sessionId, action.x, action.y);
        break;
      case 'type':
        await type(sessionId, action.text);
        break;
      case 'scroll':
        await scroll(sessionId, action.x, action.y, action.deltaY);
        break;
    }
    
    // Wait for page changes
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  // 4. Take new screenshot to verify results
  const newScreenshot = await takeScreenshot(sessionId);
  return visionModel.verifySuccess(newScreenshot, task);
}
```

### Coordinate-Based Element Targeting

Unlike traditional web automation that relies on CSS selectors, OS-level control uses visual coordinates:

```javascript
// Traditional approach (limited by DOM structure)
// await page.click('#submit-button');

// OS-level approach (works with any visual element)
const coordinates = await findElementVisually(screenshot, 'submit button');
await click(sessionId, coordinates.x, coordinates.y);
```

## Best Practices

### Human-Like Interactions

Simulate realistic user behavior for better success rates:

```javascript
// Add realistic delays
await click(sessionId, x, y);
await delay(randomBetween(100, 300));

// Use gradual scrolling
await scroll(sessionId, x, y, deltaY, { steps: 10 });

// Vary typing speed
await type(sessionId, text, { delay: randomBetween(50, 150) });
```

### Error Handling

Always verify actions with screenshots:

```javascript
async function reliableClick(sessionId, x, y, expectedChange) {
  const beforeScreenshot = await takeScreenshot(sessionId);
  await click(sessionId, x, y);
  await delay(1000);
  
  const afterScreenshot = await takeScreenshot(sessionId);
  const changed = await compareScreenshots(beforeScreenshot, afterScreenshot);
  
  if (!changed) {
    throw new Error('Click did not produce expected change');
  }
}
```

### Coordinate Accuracy

When working with vision models, ensure coordinate precision:

```javascript
// Use device pixel ratio for high-DPI displays
const devicePixelRatio = await getDevicePixelRatio(sessionId);
const adjustedX = Math.round(x * devicePixelRatio);
const adjustedY = Math.round(y * devicePixelRatio);

await click(sessionId, adjustedX, adjustedY);
```

## Limitations and Considerations

### Session Requirements

- **Headful Sessions Only**: OS-level control requires a visible desktop environment
- **Performance Impact**: Screenshots and precise positioning may be slower than DOM-based automation
- **Coordinate Dependency**: Layout changes can break coordinate-based interactions

### Security Considerations

- OS-level control has the same permissions as the browser session
- Screenshot data contains sensitive visual information
- Always validate coordinates before executing actions

### When to Use Traditional Automation

Consider CDP/DOM-based automation when:
- Working with known, stable web applications
- Performance is critical
- You need to extract structured data
- Working in headless environments

Use OS-level control when:
- Building AI agents with vision capabilities
- Dealing with complex, dynamic interfaces
- Simulating realistic user behavior
- Working with non-standard web elements

---

OS-level control opens up powerful possibilities for AI-driven browser automation, enabling more natural and effective interactions that mirror human behavior while providing the precision needed for reliable automation workflows. 